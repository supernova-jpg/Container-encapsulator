From: Claude Code <noreply@anthropic.com>
Date: Sun, 1 Sep 2025 12:00:00 +0000
Subject: [PATCH] Fix FFmpeg command generation to include video metadata

This patch fixes the critical FFmpeg processing failures by:
1. Integrating MediaInfo data with FFmpeg command generation
2. Adding resolution, framerate, and bit depth parameters to commands
3. Implementing automatic file analysis on add operations
4. Removing manual "Analyze Files" button requirement
5. Fixing log text color for Windows theme adaptation

The FileProcessor now receives and utilizes MediaInfo data to build
proper FFmpeg commands with complete metadata, ensuring successful
processing of raw video streams and containers.

---
 src/core/FileProcessor.h   |  6 ++-
 src/core/FileProcessor.cpp | 45 +++++++++++++------
 src/ui/MainWindow.cpp      | 89 ++++++++++++++++++++------------------
 src/ui/MainWindow.ui       | 12 -----
 4 files changed, 85 insertions(+), 67 deletions(-)

diff --git a/src/core/FileProcessor.h b/src/core/FileProcessor.h
index 1234567..7654321 100644
--- a/src/core/FileProcessor.h
+++ b/src/core/FileProcessor.h
@@ -9,6 +9,7 @@
 #include <QFileInfo>
 
 class MuxingTask;
+struct MediaInfo;
 
 class FileProcessor : public QObject
 {
@@ -19,7 +20,8 @@ public:
     ~FileProcessor();
 
     void processFiles(const QStringList &files, const QString &outputFolder, 
-                     const QString &format, bool overwrite = false);
+                     const QString &format, const QVector<MediaInfo> &mediaInfos,
+                     bool overwrite = false);
     void stop();
     
     bool isProcessing() const { return m_processing; }
@@ -36,7 +38,8 @@ private slots:
 
 private:
     void startNextTask();
-    QString buildFFmpegCommand(const QString &inputFile, const QString &outputFile, const QString &format);
+    QString buildFFmpegCommand(const QString &inputFile, const QString &outputFile, 
+                              const QString &format, const MediaInfo &mediaInfo);
     QString findFFmpegExecutable();
     
     QQueue<MuxingTask*> m_taskQueue;
@@ -45,6 +48,7 @@ private:
     QStringList m_files;
     QString m_outputFolder;
     QString m_outputFormat;
+    QVector<MediaInfo> m_mediaInfos;
     bool m_overwrite;
     bool m_processing;
     
diff --git a/src/core/FileProcessor.cpp b/src/core/FileProcessor.cpp
index 1234567..7654321 100644
--- a/src/core/FileProcessor.cpp
+++ b/src/core/FileProcessor.cpp
@@ -1,5 +1,6 @@
 #include "FileProcessor.h"
 #include "MuxingTask.h"
+#include "../ui/MainWindow.h"
 #include <QCoreApplication>
 #include <QDir>
 #include <QStandardPaths>
@@ -23,12 +24,13 @@ FileProcessor::~FileProcessor()
 }
 
 void FileProcessor::processFiles(const QStringList &files, const QString &outputFolder, 
-                               const QString &format, bool overwrite)
+                               const QString &format, const QVector<MediaInfo> &mediaInfos,
+                               bool overwrite)
 {
     if (m_processing) {
         emit logMessage("Already processing files. Stop current operation first.");
         return;
     }
     
     m_files = files;
     m_outputFolder = outputFolder;
     m_outputFormat = format;
+    m_mediaInfos = mediaInfos;
     m_overwrite = overwrite;
     m_processing = true;
     m_currentIndex = 0;
@@ -54,7 +58,8 @@ void FileProcessor::processFiles(const QStringList &files, const QString &outpu
     }
     
     // Create tasks for all files
-    foreach (const QString &inputFile, m_files) {
+    for (int i = 0; i < m_files.size(); ++i) {
+        const QString &inputFile = m_files[i];
         QFileInfo inputInfo(inputFile);
         QString outputName = inputInfo.completeBaseName() + "_muxed." + m_outputFormat;
         QString outputFile = QDir(m_outputFolder).absoluteFilePath(outputName);
@@ -74,7 +79,10 @@ void FileProcessor::processFiles(const QStringList &files, const QString &outpu
         MuxingTask *task = new MuxingTask(this);
         task->setFiles(inputFile, outputFile);
         
-        QString command = buildFFmpegCommand(inputFile, outputFile, m_outputFormat);
+        // Use MediaInfo if available, otherwise create default
+        MediaInfo mediaInfo = (i < m_mediaInfos.size()) ? m_mediaInfos[i] : MediaInfo();
+        
+        QString command = buildFFmpegCommand(inputFile, outputFile, m_outputFormat, mediaInfo);
         task->setFFmpegCommand(command);
         
         connect(task, &MuxingTask::finished, this, &FileProcessor::onTaskFinished);
@@ -156,7 +164,8 @@ void FileProcessor::onTaskFinished(bool success, const QString &message)
     }
 }
 
-QString FileProcessor::buildFFmpegCommand(const QString &inputFile, const QString &outputFile, const QString &format)
+QString FileProcessor::buildFFmpegCommand(const QString &inputFile, const QString &outputFile, 
+                                        const QString &format, const MediaInfo &mediaInfo)
 {
     QStringList args;
     
@@ -164,9 +173,27 @@ QString FileProcessor::buildFFmpegCommand(const QString &inputFile, const QStri
     args << "-i" << QDir::toNativeSeparators(inputFile);
     
-    // Copy streams (no re-encoding)
-    args << "-c" << "copy";
+    // For raw streams or files without proper metadata, add required parameters
+    if (mediaInfo.isRawStream || !mediaInfo.analyzed) {
+        // Add video codec if available
+        if (!mediaInfo.videoCodec.isEmpty() && mediaInfo.videoCodec != "Unknown") {
+            if (mediaInfo.videoCodec.contains("H.264", Qt::CaseInsensitive)) {
+                args << "-c:v" << "libx264";
+            } else if (mediaInfo.videoCodec.contains("H.265", Qt::CaseInsensitive)) {
+                args << "-c:v" << "libx265";
+            }
+        }
+        
+        // Add resolution if available
+        if (!mediaInfo.resolution.isEmpty() && !mediaInfo.resolution.contains("Unknown")) {
+            QString resolution = mediaInfo.resolution;
+            resolution.remove(QRegExp("\\s*\\([^)]*\\)")); // Remove description like "(FHD)"
+            if (resolution.contains("x")) {
+                args << "-s" << resolution.split(" ").first(); // Get just the resolution part
+            }
+        }
         
+        // Add frame rate if available
+        if (!mediaInfo.frameRate.isEmpty() && !mediaInfo.frameRate.contains("Unknown")) {
+            QString frameRate = mediaInfo.frameRate;
+            frameRate.remove(" fps").remove("fps");
+            bool ok;
+            double fps = frameRate.toDouble(&ok);
+            if (ok && fps > 0) {
+                args << "-r" << QString::number(fps);
+            }
+        }
+        
+        // Add pixel format based on bit depth
+        if (!mediaInfo.bitDepth.isEmpty() && !mediaInfo.bitDepth.contains("Unknown")) {
+            if (mediaInfo.bitDepth.contains("10")) {
+                args << "-pix_fmt" << "yuv420p10le";
+            } else if (mediaInfo.bitDepth.contains("8")) {
+                args << "-pix_fmt" << "yuv420p";
+            }
+        }
+    } else {
+        // For analyzed container files, copy streams
+        args << "-c" << "copy";
+    }
+    
     // Map all streams
     args << "-map" << "0";
     
diff --git a/src/ui/MainWindow.cpp b/src/ui/MainWindow.cpp
index 1234567..7654321 100644
--- a/src/ui/MainWindow.cpp
+++ b/src/ui/MainWindow.cpp
@@ -10,6 +10,7 @@
 #include <QHeaderView>
 #include <QComboBox>
 #include <QDateTime>
+#include <QApplication>
 #include <QItemDelegate>
 #include <QTimer>
 
@@ -89,7 +90,6 @@ void MainWindow::setupConnections()
     connect(ui->addFolderBtn, &QPushButton::clicked, this, &MainWindow::addFolder);
     connect(ui->removeBtn, &QPushButton::clicked, this, &MainWindow::removeSelected);
     connect(ui->clearBtn, &QPushButton::clicked, this, &MainWindow::clearAll);
-    connect(ui->analyzeBtn, &QPushButton::clicked, this, &MainWindow::analyzeFiles);
     
     // Settings
     connect(ui->browseBtn, &QPushButton::clicked, this, &MainWindow::browseOutputFolder);
@@ -154,6 +154,9 @@ void MainWindow::addFiles()
         "Video Files (*.mp4 *.mkv *.avi *.mov *.wmv *.flv *.webm *.m4v *.3gp *.ts *.h264 *.h265 *.bin *.264 *.265);;All Files (*)"
     );
     
-    addFilesToTable(files);
+    if (!files.isEmpty()) {
+        addFilesToTable(files);
+        analyzeFiles(); // Automatically analyze added files
+    }
 }
 
 void MainWindow::addFolder()
@@ -172,7 +175,10 @@ void MainWindow::addFolder()
         foreach (const QFileInfo &fileInfo, fileInfos) {
             files << fileInfo.absoluteFilePath();
         }
-        addFilesToTable(files);
+        if (!files.isEmpty()) {
+            addFilesToTable(files);
+            analyzeFiles(); // Automatically analyze added files
+        }
     }
 }
 
@@ -141,6 +144,9 @@ void MainWindow::dropEvent(QDropEvent *event)
             }
         }
-        addFilesToTable(files);
+        if (!files.isEmpty()) {
+            addFilesToTable(files);
+            analyzeFiles(); // Automatically analyze dropped files
+        }
     }
 }
 
@@ -202,7 +208,6 @@ void MainWindow::analyzeFiles()
     }
     
     logMessage("Starting media analysis...", LogLevel::Info);
-    ui->analyzeBtn->setEnabled(false);
     
     for (int i = 0; i < m_files.size(); ++i) {
         m_analyzer->analyzeFile(i, m_files[i]);
@@ -262,7 +267,7 @@ void MainWindow::startProcessing()
     
     logMessage("Starting batch processing...", LogLevel::Info);
-    m_processor->processFiles(m_files, outputFolder, getOutputFormat(), overwrite);
+    m_processor->processFiles(m_files, outputFolder, getOutputFormat(), m_mediaInfos, overwrite);
 }
 
 void MainWindow::stopProcessing()
@@ -354,11 +359,8 @@ void MainWindow::onMediaAnalysisFinished(int index, const MediaInfo &info)
     // Check if all analysis is complete
     static int completedAnalysis = 0;
     completedAnalysis++;
-    
     if (completedAnalysis >= m_files.size()) {
-        ui->analyzeBtn->setEnabled(true);
         logMessage("Media analysis completed", LogLevel::Info);
         completedAnalysis = 0;
     }
 }
@@ -611,6 +613,29 @@ QString MainWindow::formatFileSize(qint64 size)
 void MainWindow::logMessage(const QString &message, LogLevel level)
 {
     if (!shouldShowLogLevel(level)) {
         return;
     }
     
     QString timestamp = QDateTime::currentDateTime().toString("hh:mm:ss");
     QString levelStr;
     QString color;
     
+    // Detect Windows theme and adapt colors accordingly
+    bool isDarkTheme = false;
+#ifdef Q_OS_WIN
+    // Check if Windows is in dark mode
+    QSettings settings("HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize", 
+                      QSettings::NativeFormat);
+    isDarkTheme = (settings.value("AppsUseLightTheme", 1).toInt() == 0);
+#endif
+    
+    // Use palette-aware colors as fallback
+    QPalette palette = QApplication::palette();
+    QString defaultTextColor = palette.color(QPalette::WindowText).name();
+    
     switch (level) {
     case LogLevel::Info:
         levelStr = "[INFO]";
-        color = "black";
+        color = isDarkTheme ? "#FFFFFF" : (defaultTextColor.isEmpty() ? "#000000" : defaultTextColor);
         break;
     case LogLevel::Warning:
         levelStr = "[WARN]";
-        color = "orange";
+        color = "#FFA500"; // Orange works in both themes
         break;
     case LogLevel::Error:
         levelStr = "[ERROR]";
-        color = "red";
+        color = "#FF4444"; // Lighter red for better visibility in dark themes
         break;
     }
     
diff --git a/src/ui/MainWindow.ui b/src/ui/MainWindow.ui
index 1234567..7654321 100644
--- a/src/ui/MainWindow.ui
+++ b/src/ui/MainWindow.ui
@@ -69,18 +69,6 @@
        </item>
        <item>
-        <widget class="QPushButton" name="analyzeBtn">
-         <property name="text">
-          <string>Analyze Files</string>
-         </property>
-         <property name="toolTip">
-          <string>Analyze media information for all files</string>
-         </property>
-        </widget>
-       </item>
-       <item>
         <spacer name="fileButtonSpacer">
          <property name="orientation">
           <enum>Qt::Horizontal</enum>
-- 
2.34.1